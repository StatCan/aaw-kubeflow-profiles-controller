package cmd

import (
	"context"
	"time"

	kubeflowv1 "github.com/StatCan/profiles-controller/pkg/apis/kubeflow/v1"
	"github.com/StatCan/profiles-controller/pkg/controllers/profiles"
	kubeflowclientset "github.com/StatCan/profiles-controller/pkg/generated/clientset/versioned"
	kubeflowinformers "github.com/StatCan/profiles-controller/pkg/generated/informers/externalversions"
	"github.com/StatCan/profiles-controller/pkg/signals"
	"github.com/spf13/cobra"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kubeinformers "k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog"
)

// This controller works with namespaces generated by the profile custom resource
const filerInjectionLabel = "filer-sidecar-injection"
const namespaceCreatedByProfileLabel = "app.kubernetes.io/part-of" // Should have value `kubeflow-profile`

var namespaceCmd = &cobra.Command{
	Use:   "namespace",
	Short: "Configure namespace generated by profile",
	Long:  `Configure namespace generated by profile`,
	Run: func(cmd *cobra.Command, args []string) {
		// Setup signals so we can shutdown cleanly
		stopCh := signals.SetupSignalHandler()

		// Create Kubernetes config
		cfg, err := clientcmd.BuildConfigFromFlags(apiserver, kubeconfig)
		if err != nil {
			klog.Fatalf("error building kubeconfig: %v", err)
		}

		// Builds k8s client for us to use, pass this in to functions for us to use
		kubeClient, err := kubernetes.NewForConfig(cfg)
		if err != nil {
			klog.Fatalf("Error building kubernetes clientset: %s", err.Error())
		}

		kubeflowClient, err := kubeflowclientset.NewForConfig(cfg)
		if err != nil {
			klog.Fatalf("error building Kubeflow client: %v", err)
		}

		// Setup informers
		// kubeflow informer is necessary for watching profile updates
		kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Minute*(time.Duration(requeue_time)))
		kubeflowInformerFactory := kubeflowinformers.NewSharedInformerFactory(kubeflowClient, time.Minute*(time.Duration(requeue_time)))

		// Setup controller
		controller := profiles.NewController(
			kubeflowInformerFactory.Kubeflow().V1().Profiles(),
			func(profile *kubeflowv1.Profile) error { // on a current profile
				// List of labels that each namespace should have.
				newLabels := map[string]string{
					filerInjectionLabel: "enabled",
				}
				// Get current namespace associated with profile via profile.metadata.name matching to namespace.metadata.name
				currentNs, err := kubeClient.CoreV1().Namespaces().Get(context.Background(), profile.ObjectMeta.Name, metav1.GetOptions{})
				if err != nil {
					klog.Infof("An Error occured while retrieving associated namespace info %v", err)
				}

				setNamespaceLabels(currentNs, newLabels)
				_, errUpdate := kubeClient.CoreV1().Namespaces().Update(context.Background(), currentNs, metav1.UpdateOptions{}) // something like this
				if errUpdate != nil {
					klog.Infof("An Error occured while setting new namespace %v", err)
				}

				return nil
			}, // end controller setup
		)

		kubeInformerFactory.Start(stopCh)
		kubeflowInformerFactory.Start(stopCh)

		// Run the controller
		if err = controller.Run(2, stopCh); err != nil {
			klog.Fatalf("error running controller: %v", err)
		}
	},
}

func setNamespaceLabels(ns *corev1.Namespace, newLabels map[string]string) {
	if ns.Labels == nil {
		ns.Labels = make(map[string]string)
	}

	for k, v := range newLabels {
		_, ok := ns.Labels[k]
		if len(v) == 0 {
			// When there is an empty value, k should be removed.
			if ok {
				delete(ns.Labels, k)
			}
		} else {
			if !ok {
				// Add label if not exist, otherwise skipping update.
				ns.Labels[k] = v
			}
		}
	}
}

func init() {
	rootCmd.AddCommand(namespaceCmd)
}
